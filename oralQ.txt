1. Какой самый эффективный способ конкатенации строк?

strings.Builder потому что сводит к минимуму копирование в память

var sb strings.Builder
for i := 0; i < 10; i++ {
    sb.WriteString("a")
}
fmt.Println(sb.String())

2. Что такое интерфейсы, как они применяются в Go?


Интерфейс - это тип в Go, который представляет собой набор сигнатур методов. 
Эти коллекции сигнатур методов предназначены для представления определенного 
поведения. Интерфейс объявляет только набор методов, и любой тип, который 
реализует все методы интерфейса, относится к этому типу интерфейса.

Duck typing

Помогает писать более модульный и несвязанный код между различными частями 
кодовой базы – Это может помочь уменьшить зависимость между различными частями 
кодовой базы и обеспечить слабую связь.

Интерфейс может использоваться для достижения полиморфизма.

3. Чем отличаются RWMutex от Mutex?

RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, 
но можно параллельно читать. Например, стандартный тип map.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

4. Чем отличаются буферизированные и не буферизированные каналы?

Канал не блокирует горутину пока буфер не заполнится. Горутина считывает буфер пока он не станет пустым.

5. Какой размер у структуры struct{}{}?

0 байт

6. Есть ли в Go перегрузка методов или операторов?

Нет
Отправка метода упрощается, если ему также не нужно выполнять сопоставление типов. Опыт работы с другими 
языками подсказывал нам, что наличие множества методов с одинаковыми именами, но разными сигнатурами иногда 
полезно, но на практике это также может привести к путанице и хрупкости. Сопоставление только по имени и 
требование согласованности в типах было основным упрощающим решением в системе типов Go.

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

В рандомном порядке.
НО если отсортировать ключи и выводить по уже отсортированным ключам то вывод будет а отсортированном порядке

8. В чем разница make и new?

make создает только slices, maps, и channels,
new возвращает только указатели на инициализированную память.

9. Сколько существует способов задать переменную типа slice или map?

m := make(map[string]int) m := make(map[string]int, 100) 
m := map[string]int{
    "a": 1,
    "b": 2,
}
var m map[string]int

10. Что выведет данная программа и почему?

func update(p *int) {
    b := 2
    p = &b
}
func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}

Вывод:
1
1

В функции меняется копия p

11. Что выведет данная программа и почему?

func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}

Числа от 0 до 4 в рандомном порядке и упадет в дедлок, нужно передавать указатель на Wg

func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg *sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(&wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}

12. Что выведет данная программа и почему?

func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}

0, в id объявляется новая переменная n, область видимости

13. Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}

[100 2 3 4 5]

в функции v - копия слайса с указателями на массив , 0ой элемент которого мы изменили.

14. Что выведет данная программа и почему?

func main() {
    slice := []string{"a", "a"}

    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)

    fmt.Print(slice)
}

[b b a][a a]

В анонимной функции после выполнения slice = append(slice, "a") слайс начинает ссылаться на новый массив ["a","a","a"]
если бы мы создали слайс с cap 3 то вывод был бы [b b a][b b]